# 김 영환
### 202530206

## 09월11일 강의

# 09월-04일 강의


# 10월-23일 강의
*검색 알고리즘이란*
*배열 검색*
**선형검색**
무작위로 늘어놓는 데이터 모임에서 검색을 수행
  선형 검색 다루기(2): 요소 개수가 n인 배열 a에서 값이 key인 요소를 검색하는 코드
   배열을 검색할 때 배열 요소의 인덱스를 가리키는 변수는 i
   i는 0으로 초기화하고, 요소를 하나 검색할 때마다 while문이 제어하는 루프 본문의 끝에서 증가
   배열 검색
  선형검색 다루기(3): search 함수는 배열 a의 처음부터 끝까지 n개의 요소를 대상으로 값이 key인 요소를 선형 검색
   반환값은 발견한 요소의 인덱스
   만약 값이 key인 요소가 여러 개 존재한다면 반환값은 검색 과정에서 처음 발견한 요소의 인덱스
   값이 key인 요소가 존재하지 않으면 -1을 반환
  선형 검색 다루기(4): 선형 검색을 구현한 프로그램
**이진 검색**
일정한 규칙으로 늘어놓은 데이터 모임에서 아주 빠른 검색을 수행
  이진 검색 다루기(1): 요소가 오름차순 또는 내림차순으로 정렬된 배열에서 검색하는 알고리즘
   이진 검색에서 배열 검색의 종료조건: 
    1 중앙 요소와 key가 일치하는 경우(검색 성공)
    2 검색 범위가 더 이상 없는 경우(검색 실패)
   검색에 필요한 비교 횟수
  이진 검색 다루기(2): 검색에 성공하는 예 a검색 범위의 맨 앞 인덱스를(0)를 pl, 맨 끝 인덱스(n-1)를 pr,중앙 인덱스 ((n-2)/2)를 pc라고 지정
   a -> b a[pc] < key
    a[pl]~a[pc]는 key보다 작은 것이 분명하므로 검색 대상에서 제외
    검색 범위는 중앙 요소 a[pc]보다 뒤쪽의 a[pc+1]~a[pr]로 좁혀짐
    그런 다음 pl의 값을 pc +1로 업데이트
   b -> c a[pc] > key

**bsearch** : C언어의 표준 라이브러리는 다양한 요소의 자료형을 가진 배열에서도 검색 가능한 bsearch 함수를 제공
  함수특징: 특징1 검색 대상의 배열은 항상 정렬되어 있어야함. 특징2 검색하는 값과 같은 요소가 여러 개 존재하는 경우, 항상 가장 앞쪽에 있는 요소를 찾아내는 건 아님







**해시법**
추가, 삭제가 자주 일어나는 데이터 모임에서 아주 빠른 검색을 수행
    *체인법* 같은 해시값의 데이터를 선형 리스트로 연결하는 방법
    *오픈 주소법* 데이터를 위한 해시값이 충돌할 때 재해시하는 방법

# 10월-31일 강의
  **버블 정렬**
   pass / 이웃한 요소를 비교하고 교환하는 작업을 첫 번째 요소까지 계속하면 그림 6-3과 같은 상태가 됨
   요소의 개수가 n개인 배열에서 n - 1회 비교, 교환을 하고 나면 가장 작은 요소가 맨 처음으로 이동
   이런 일련의 과정(비교,교환 작업)을 pass 라고 함

  **단순 선택 정렬**
   단순선택정렬 : 아직 정렬하지 않은 부분에서 값이 가장 작은 요소를 선택하고 아직 정렬하지 않은 부분의 첫 번째 요소와 교환
  **교환과정**
   1. 아직 정렬하지 않은 부분에서 가장 작은 키의 값 (a[min])을 선택
   2. a([min])과 아직 정렬하지 않은 부분의 첫 번째 요소를 교환
  **실습**
단순 선택 정렬을 수행하는 함수
   단순 선택 정렬 알고리즘의 요소값을 비교하는 횟수는 2회
   이 정렬 알고리즘은 서로 떨어져 있는 요소를 교환하는 것이기 때문에 안정적이지 않음
  **단순 삽입 정렬**
  단순 삽입 정렬 선택한 요소를 그보다 더 앞쪽의 알맞은 위치에 삽입하는 작업을 반복하여 정렬하는 알고리즘
   아래의 두 조건중 하나를 만족할 때까지 j를 1씩 감소하면서 대입하는 작업을 반복
    1. 정렬된 열의 왼쪽 끝에 도달
    2. tmp 보다 작거나 같은 key를 갖는 항복 a[j - 1]을 발견
  **셸 정렬**
   단순 삽입 정렬의 특징
     정렬을 마쳤거나 정렬을 마친 상태에 가까우면 정렬 속도가 매우 빨라짐(장점)
     삽입할 위치가 멀리 떨어져 있으면 이동(대입)해야 하는 횟수가 많아짐 (단점)
   단순 삽입 정렬의 장점은 살리고 단점은 보완한 정렬 알고리즘
   정렬할 배열의 요소를 그룹으로 나눠 각 그룹별로 단순 삽입 정렬을 수행
   그 그룹을 합치면서 정렬을 반복하여 요소의 이동 횟수를 줄이는 방법
   *4-정렬* 4칸만큼 떨어진 요소를 모아 그룹을 4개로 나누어 정렬하는 방법
   아직 정렬을 마친 상태는 아니지만 정렬을 마친 상태에 가까워짐
   **셸 정렬 살펴보기**
   2칸만큼 떨어진 요소를 모아 두 그룹({7,3,8,4}),{1,2,6,5}으로 나누어 2-정렬을 함
   정렬을 마치고 나면 각각의 그룹은 {3,4,7,8}, {1,2,5,6}으로 정렬 됨
   **h 정렬**
   셸 정렬 과정에서 수행하는 각각의 정렬
   1,2개 요소에 대해 `4-정렬`(4개의 그룹)
   2,4개 요소에 대해 `2-정렬`(2개의 그룹)
   3,8개 요소에 대해 `1-정렬`(1개의 그룹)
   **중분값 (h값)의 선택**
   h값은 n부터 감소하여 마지막에 1이 되면 됨
   이렇게 그룹이 섞이지 않으면 c를 합쳤을 때 다시 처음 단계인 a와 동일한 상태가 됨
   그러면 다시 a의 학생을 정렬하는 것과 같아서 기껏 그룹을 나누었음에도 정렬 알고리즘이 충분히 작동하지 않음
   **퀵 정렬**
   일반적으로 사용되고 있는 아주 빠른 정렬 알고리즘
   먼저 어느 한 사람의 키를 선택
   키가 168cm인 학생 A를 선택할 경우 그 학생을 기준으로 학생 A의 키보다 작은 사람의 그룹과 큰 사람의 그룹으로 나눔
   이때 이 학생 A의 키를 (그룹을 나누는 기준) 피벗 (pivot) 이라고 함
   퀵 정렬은 각 그룹에 대해 피벗 설정과 그룹 나눔을 반복하며 모든 그룹이 1명이 되면 정렬을 마침





# [문자 크기](#h1에-해당) / [리스트](#리스트)

```md
# h1에 해당
## h2
### h3
#### h4
##### h5
###### h6
```


*이탤릭 체*  
**볼드 체**  
***하이픈***  
---
* 언오더드 리스트
- 언  
    *탭  
    *탭  
        *탭  
        *탭

1. 오더드 리스트
2.

# 코드 블럭

```c
#include <stdio.h>

int main()
{
    printf("Hello, world")

}
```
인라인 코드 블럭 예 : `<br>` 다른예 : `Ctrl`+`A`

#와부링크
[구글로 가기](https://google.com "구글 링크")
# [내부](#)

![이미지](/1.jpg "이미지 삽입")






abcdefgujyfurfty