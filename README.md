# 김 영환
### 202530206

## 09월11일 강의

# 09월-04일 강의


# 10월-23일 강의
*검색 알고리즘이란*

*배열 검색*

**선형검색**
무작위로 늘어놓는 데이터 모임에서 검색을 수행
  선형 검색 다루기(2): 요소 개수가 n인 배열 a에서 값이 key인 요소를 검색하는 코드
   배열을 검색할 때 배열 요소의 인덱스를 가리키는 변수는 i
   i는 0으로 초기화하고, 요소를 하나 검색할 때마다 while문이 제어하는 루프 본문의 끝에서 증가
   배열 검색

  선형검색 다루기(3): search 함수는 배열 a의 처음부터 끝까지 n개의 요소를 대상으로 값이 key인 요소를 선형 검색
   반환값은 발견한 요소의 인덱스
   만약 값이 key인 요소가 여러 개 존재한다면 반환값은 검색 과정에서 처음 발견한 요소의 인덱스
   값이 key인 요소가 존재하지 않으면 -1을 반환

  선형 검색 다루기(4): 선형 검색을 구현한 프로그램


**이진 검색**
일정한 규칙으로 늘어놓은 데이터 모임에서 아주 빠른 검색을 수행

  이진 검색 다루기(1): 요소가 오름차순 또는 내림차순으로 정렬된 배열에서 검색하는 알고리즘
   이진 검색에서 배열 검색의 종료조건: 
    1 중앙 요소와 key가 일치하는 경우(검색 성공)
    2 검색 범위가 더 이상 없는 경우(검색 실패)
   검색에 필요한 비교 횟수

  이진 검색 다루기(2): 검색에 성공하는 예 a검색 범위의 맨 앞 인덱스를(0)를 pl, 맨 끝 인덱스(n-1)를 pr,중앙 인덱스 ((n-2)/2)를 pc라고 지정
   a -> b a[pc] < key
    a[pl]~a[pc]는 key보다 작은 것이 분명하므로 검색 대상에서 제외
    검색 범위는 중앙 요소 a[pc]보다 뒤쪽의 a[pc+1]~a[pr]로 좁혀짐
    그런 다음 pl의 값을 pc +1로 업데이트
   b -> c a[pc] > key

**bsearch** : C언어의 표준 라이브러리는 다양한 요소의 자료형을 가진 배열에서도 검색 가능한 bsearch 함수를 제공
  함수특징: 특징1 검색 대상의 배열은 항상 정렬되어 있어야함. 특징2 검색하는 값과 같은 요소가 여러 개 존재하는 경우, 항상 가장 앞쪽에 있는 요소를 찾아내는 건 아님







**해시법**
추가, 삭제가 자주 일어나는 데이터 모임에서 아주 빠른 검색을 수행
    *체인법* 같은 해시값의 데이터를 선형 리스트로 연결하는 방법
    *오픈 주소법* 데이터를 위한 해시값이 충돌할 때 재해시하는 방법

# 10월-31일 강의
  **버블 정렬**
   pass / 이웃한 요소를 비교하고 교환하는 작업을 첫 번째 요소까지 계속하면 그림 6-3과 같은 상태가 됨
   요소의 개수가 n개인 배열에서 n - 1회 비교, 교환을 하고 나면 가장 작은 요소가 맨 처음으로 이동
   이런 일련의 과정(비교,교환 작업)을 pass 라고 함

  **단순 선택 정렬**
   단순선택정렬 : 아직 정렬하지 않은 부분에서 값이 가장 작은 요소를 선택하고 아직 정렬하지 않은 부분의 첫 번째 요소와 교환


  **교환과정**
   1. 아직 정렬하지 않은 부분에서 가장 작은 키의 값 (a[min])을 선택
   2. a([min])과 아직 정렬하지 않은 부분의 첫 번째 요소를 교환


  **실습**
단순 선택 정렬을 수행하는 함수
   단순 선택 정렬 알고리즘의 요소값을 비교하는 횟수는 2회
   이 정렬 알고리즘은 서로 떨어져 있는 요소를 교환하는 것이기 때문에 안정적이지 않음


  **단순 삽입 정렬**
  단순 삽입 정렬 선택한 요소를 그보다 더 앞쪽의 알맞은 위치에 삽입하는 작업을 반복하여 정렬하는 알고리즘
   아래의 두 조건중 하나를 만족할 때까지 j를 1씩 감소하면서 대입하는 작업을 반복
    1. 정렬된 열의 왼쪽 끝에 도달
    2. tmp 보다 작거나 같은 key를 갖는 항복 a[j - 1]을 발견


  **셸 정렬**
   단순 삽입 정렬의 특징
     정렬을 마쳤거나 정렬을 마친 상태에 가까우면 정렬 속도가 매우 빨라짐(장점)
     삽입할 위치가 멀리 떨어져 있으면 이동(대입)해야 하는 횟수가 많아짐 (단점)
   단순 삽입 정렬의 장점은 살리고 단점은 보완한 정렬 알고리즘
   정렬할 배열의 요소를 그룹으로 나눠 각 그룹별로 단순 삽입 정렬을 수행
   그 그룹을 합치면서 정렬을 반복하여 요소의 이동 횟수를 줄이는 방법


   *4-정렬* 4칸만큼 떨어진 요소를 모아 그룹을 4개로 나누어 정렬하는 방법
   아직 정렬을 마친 상태는 아니지만 정렬을 마친 상태에 가까워짐


   **셸 정렬 살펴보기**
   2칸만큼 떨어진 요소를 모아 두 그룹({7,3,8,4}),{1,2,6,5}으로 나누어 2-정렬을 함
   정렬을 마치고 나면 각각의 그룹은 {3,4,7,8}, {1,2,5,6}으로 정렬 됨


   **h 정렬**
   셸 정렬 과정에서 수행하는 각각의 정렬
   1,2개 요소에 대해 `4-정렬`(4개의 그룹)
   2,4개 요소에 대해 `2-정렬`(2개의 그룹)
   3,8개 요소에 대해 `1-정렬`(1개의 그룹)


   **중분값 (h값)의 선택**
   h값은 n부터 감소하여 마지막에 1이 되면 됨
   이렇게 그룹이 섞이지 않으면 c를 합쳤을 때 다시 처음 단계인 a와 동일한 상태가 됨
   그러면 다시 a의 학생을 정렬하는 것과 같아서 기껏 그룹을 나누었음에도 정렬 알고리즘이 충분히 작동하지 않음


   **퀵 정렬**
   일반적으로 사용되고 있는 아주 빠른 정렬 알고리즘
   먼저 어느 한 사람의 키를 선택
   키가 168cm인 학생 A를 선택할 경우 그 학생을 기준으로 학생 A의 키보다 작은 사람의 그룹과 큰 사람의 그룹으로 나눔
   이때 이 학생 A의 키를 (그룹을 나누는 기준) 피벗 (pivot) 이라고 함
   퀵 정렬은 각 그룹에 대해 피벗 설정과 그룹 나눔을 반복하며 모든 그룹이 1명이 되면 정렬을 마침

   **배열을 두 그룹으로 나누기**
   그룹을 나누려면 피벗 이하의 요소를 배열 왼쪽으로, 이상의 요소를 배열 오른쪽으로 옮겨야함
   그룹을 나누는 작업이 끝난 다음 pl > pr + 1인 경우에는 다음과 같은 그룹이 생길 수 있음
   b c d 왼쪽 커서, 오른쪽 커서가 피벗 이상 피벗 이하의 요소를 찾아 멈춘 단계
   d pl, pr이 동일한 요소 a[4] 위에 있음
   이때 동일한 요소인 a[4]와 a[4]를 교환
   e 계속 스캔하면 pl,pr이 교차하면서 그룹을 나누는 과정을 마침

# 11월-6일 강의
   **qsort**
   qsort함수는 bsearch함수와 마찬가지로 int형이나 double형 등의 배열뿐만 아니라 구조체형 배열 등 모든 자료형의 배열에 적용할 수 있음
   qsort함수에 전달하는 4개 인수는 앞에서부터 차례대로 배열의 첫 번째 요소에 대한 포인터, 요소의 개수, 요소의 크기, 비교 함수에 대한 포인터
   비교 함수는 아래의 값을

   **병합정렬**
   #a, b모두 정렬이 끝난 배열의 조건
   각 배열에서 선택한 요소의 값을 비교하여 작은 값의 요소를 꺼내 새로운 배열에 넣는 작업을 반복하여 정렬을 마치는 배열을 만듦

   merge 함수는 요소의 개수가 na개인 배열 a와 요소의 개수가 nb개인 배열 b를 병합하여 배열 c에 저장

   이 함수에서는 세 개의 배열 a, b, c를 동시에 스캔
   이때 각 배열이 선택한 요소의 인덱스는 pa, pb, pc 이 인덱스를 저장한 변수를 커서라고 함

   처음에는 첫 요소를 선택하므로 커서를 모두 0으로 초기화

   **실습 6-14-(1)**
   배열 a에서 선택한 요소 (a[pa])와 배열 b에서 선택한 요소(b[pb])를 비교하여 작은 값을 (c[pc])에 저장
   
   **병합 정렬하기(1)**
   정렬을 마친 배열의 병합을 응용하여 분할 정복법에 따라 정렬하는 알고리즘

   먼저 배열을 앞부분과 뒷부분으로 나눔
   
   나눈 두 배열을 각각 정렬하고 병합하면 배열 모두를 정렬할 수 있음

   병합 정렬 알고리즘

   배열의 요소 개수가 2개 이상인 경우
   
   **힙 정의하기**
   부모의 값이 자식의 값보다 항상 크다 는 조건을 만족하는 완전 이진트리
   a는 힙이 아닌 완전 이진트리
   a를 힙으로 만들면 b와 같은 상태가 됨

   **힙 정렬**
   가장 큰 값이 루트에 위치하는 특징을 이용하는 정렬 알고리즘

   **힙 정렬(2)**
   류투룰 없앤 다음 다시 힙을 만들기 위해 요소를 알맞은 위치로 내려보내야 하는데 그 순서는 다음과 같음
   
   1. 루트를 꺼냄
   2. 마지막 요소를 루트로 이동
   3. 자기보다 큰 값을 가지는 자식 요소와 자리를 바꾸며 아래쪽으로 내려가는 작업을 반복하는데 이때 자식의 값이 작거나 잎에 다다르면 작업이 종료됨

# 11월-13일 강의
   **선형리스트**
   데이터를 순서대로 나열해 놓은 자료구조

   **선형 리스트 정의하기(1)**
   노드 : 리스트의 각 요소 (element)
   각각의 노드는 데이터와 다음 노드를 가리키는 포인터를 가지고 있음
   처음과 끝에 있는 노드는 특별히 각각 머리 노드(head node), 꼬리 노드 라고 함

   **선형 리스트 만들기**
   배열의 각 요소에는 연락할 순서대로 데이터가 저장
   
   **삽입과 삭제**
   회원번호가 55인 회원이 새로 가입했고 이 회원의 정보를 회원번호 12, 33 사이에 삽입하려면 [b]와 같이 삽입 요소 다음의 모든 요소를 하나씩 뒤로 밀어야함
   
   **원형 이중 연결 리스트**
   원형 이중 연결 리스트 만들기(5)
   노드를 생성하는 AllocDnode 함수
   Dnode형 객체를 생성하고 해당 객체의 포인터를 반환하는 함수

   원형 이중 연결 리스트 만들기(6)
   
   원형 이중 연결 리스트를 초기화하는 Initialize 함수

   텅 비어 있는 상태의 원형 이중 연결 리스트를 만드는 함수

   리스트의 머리 부분에 더미 노드가 만들어짐(노드의 삽입 삭제를 원만히 수행하기 위해 필요)

# 11월-27일 강의
   **스택 (Stack)**
   후입선풀(LIFO, LAST In First Out): 가장 나중에 넣은 데이터를 가장 먼저 꺼냄
   푸시(push): 스택에 데이터를 넣는 작업
   팝(pop): 스택에서 데이터를 꺼내는 작업
   꼭대기(top)

   **기본함수**
   Cleat(): 스택의 모든 데이터를 삭제하는 함수

   Capacity(): 용량을 확인하는 함수 데이터를 넣을 수 있는 최대 공간.

   SIze(): 데이터의 개수를 확인하는 함수.

   IsEmpty(): 스택에 비어 있는지 검사하는 함수. 비어 있으면 1, 그렇지 않으면 0을 반환.

   IsFull():

   큐(Queue) : 인큐(en-queue): 큐에 데이터를 넣는 작업.
   
   디큐(de-Queue) : 데이터를 꺼내는 작업
   
   프런트(front): 데이터를 꺼내는 쪽

   리어(rear): 데이터를 넣는 쪽
   
   Initialize 초기화 함수
   
   **검색 Search**
   선형 검색, 이진 검색

   선형 검색 : 선형검색 linear search 또는 순차 검색 이라고 함, 원하는 키 값을 갖는 데이터를 만날 때까지 맨 앞부터 순서대로 데이터를 검색. 시간 복잡도는 0
   
   이진 검색 : 오름차순 또는 내림차순으로 정렬된 데이터에서 검색, 배열의 중간 값을 선택하고 찾고자 하는 값과 비교, 만약 중간 값이 찾고자 하는 값보다 크면 배열 왼쪽에서 부분에서 탐색을 진행하고, 작으면 배열 오른쪽 부분에서 탐색을 진행함, 이 과정에서 찾고자 하는 값이 나올 때까지 반복.

   **정렬 SOrting**
   정렬 : 이름, 학번, 키 등 핵심 항복 key 의 대소 관계에 따라 데이터 집합을 일정한 순서로 줄지어 늘어서도록 바꾸는 작업, 오름차순 정렬 : 키 값이 작은 데이터 부터 큰 순서로 정렬
   
   **버블정렬**
   인접한 두 데이터를 비교하여 기준에 만족하면 데이터를 서로 교환해서 완성될 때까지 반복하는 정렬 방법. 오름차순 정렬의 두 데이터 비교하여 앞쪽 값이 더 크면 데이터를 교환 내림차순 정렬의 두 데이터 비교하여 앞쪽 값이 더 작으면 데이터를 교환, 시간 복잡도는 0

   **퀵 정렬**
   리스트 가운데서 하나의 원소를 고른다. 이렇게 고른 원소를 피벗 이라고 한다.
   피벗을 기준으로 리스트를 둘로 나눕니다
   이렇게 하면 배열이 두 부분으로 나뉘어 집니다.
   더 이상 배열을 쪼갤 수 없을 떄까지 계속 진행한다.
   재귀 적으로 이 과정을 반복한다.

   **힙Heap sort 정렬**
   최댓값, 최솟값을 쉽게 추출할 수 있는 자료구조 입니다.
   최대 힙 트리 (내림차순 정렬)나 최소 힙 트리 (오름차순 정렬)를 구성해 정렬을 하는 방법

   n개의 노드로 이루어진 완전 이진트리를 구성합니다.
   이때 루트 노드부터 부모노드, 왼쪽 자식노드, 오른쪽 자식 노드 순으로 구성합니다.
   정렬해야 할 n개의 요소들로 최대 힙 (내림 차순 기준)을 만듭니다.
   다음으로 한 번에 하나씩 요소를 힙에서 꺼내서 배열의 뒤부터 저장하면 된다.
   삭제되는 요소들 최댓값 부터 삭제은 값이 감소되는 순서로 정렬되게 된다.

   **도수 정렬 counting sort**
   원소의 대소 관계를 판단하지 않고 빠르게 정렬하는 알고리즘으로 분포 수 세기 정렬 이라고도 합니다.

   배열의 내 요소 값들의 개수를 저장하는 카운트 배열(도수 분포표) f를 생성하고 배열의 모든 원소 값을 0으로 초기화 합니다.

   **카운트 정렬**

   주어진 배열 a를 스캔하며 원소 값이 배열 F의 인덱스와 일치하는 곳에 카운트를 올리며 도수분포표를 채웁니다.

   **리스트**
   선형 리스트, 연결 리스트

   선형 리스트 Linear List, 데이터를 일렬로 나열하고 순서대로 저장하는 가장 간단한 형태의 자료 구조 입니다.

   논리적 순서와 물리적 순서가 일치하며, 메모리에 연속적을 저장되는 특징이 있습니다.

   배열이 대표적인 선형 리스트의 예 입니다.

   장점 : 인덱스로 접근할 수 있기 때문에 접근 속도가 매우 빠릅니다.

   연속된 메모리 공간에 존재하기 때문에 관리하기가 편합니다

   단점 : 배열을 이용해 구현하기 때문에 배열이 갖고 있는 메모리 사용의 비효율성 문제를 그대로 가지고 있습니다.

   삽입 & 삭제 연산 후에 연속적인 물리 주소를 유지하기 위해 원소들을 이동 시키는 추가 작업과 시간이 소요됩니다.

   **연결 리스트 Linked List**

   각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료 구조 입니다.

   데이터 노드를 저장할 때 하나의 데이터와 그 다음 데이터류 가는 주소 (다음 노드의 주소) 를 함께 저장하여, 논리적으로 연결(link)하는 방식으로 자료를 저장합니다.

   데이터는 논리적으로 연결되어 있으므로 배열과 달리 데이터의 삽입 삭제가 자유롭고, 자연스럽게 뭐시깽이

   3가지, 단순 연결 리스트, 이중 연결 리스트, 순환 연결 리스트, 원형 이중 연결 리스트
   
   제일 중요한 리스트 : 이중 연결 리스트 데이터와 함께 이전과 다음 노드의 주소를 모두 함께 가지고 있는 구조 입니다.

   **트리 Tree**
   이진트리, 완전 이진 트리, 이진 검색 트리

   트리 : 트리를 구성하는 요소는 노드(node)와 가지(edge) 두가지 입니다.
   각각의 노드는 가지를 통해 다른 노드와 연결되어 있습니다.
   루트root노드 : 트리의 가장 윗부분에 위치하는 노드로 트리에 단 한 개만 존재합니다.
   단말leaf노드 : 트리의 아랫부분에 위치하여 자식 노드가 없는 노드 입니다.
   내부internal노드 : 단말 노드가 아닌 노드가 2개
   
   노드 크기, 깊이, 레벨, 차수, 트리 차수, 트리 높이, 서브 트리, 널 트리
   
   서브 트리 : 트리 안에서 다시 어떤 노드를 루트로 정하고 그 자손으로 이루어진 트리

   널 트리 : 노드, 가지가 없는 트리

   **이진트리**
   노드가 왼쪽 자식과 오른쪽 자식을 갖는 트리

   노드의 자식은 2명 이하만 유지 해야함

   왼쪽 자식과 오른쪽 자식을 구분함

   **완전 이진 트리**
   
   루트부터 노드가 채워져 있으면서 같은 레벨에서는 왼쪽에서 오른쪽으로 노드가 채워져 있는 이진트리 1.마지막 레벨을 제외한 레벨은 노드를 가득 채움 2.마지막 레벨은 왼쪽부터 오른쪽 방향으로 노드를 채우되 반드시 끝까지 채울 필요는 없음

   높이가 k인 완전 이진트리가 가질 수 있는 노드의 최댓값은 2 -1 개
   
   따라서 n개의 노드를 저장할 수 있는 완전 이진 트리의 높이는 log n

   완전 이진 트리에서 너비 우선 탐색을 하며 각 노드에 0, 1, 2, ... 값을 주면 배열에 저장하는 인덱스와 일대일로 대응

   트리의 레벨은 루트에서부터 노드까지 거친 층의 수를 나타내며 루트는 보통 0레벨 또는 1레벨로 본다.

   높이는 트리의 최대 레벨과 같으며 루트에서 가장 먼 리프 노드까지의 경로에 있는 레벨 수(혹은 간선의 최대 개수)를 의미한다.

   **이진 검색 트리**
   
   이진 트리가 다음의 조건을 만족하면 이진 검색 트리가 됩니다.
   
   어떤 노드 N을 기준으로 왼쪽 서브 트리 노드의 모든 키 값은 노드 N의 키 값보다 작아야 함.
   
   오른쪽 서브 트리 노드의 키 값은 노드 N의 키 값보다 커야 함.
   
   같은 키 값을 갖는 노드는 없음.

   특징 : 구조가 단순하고 중위 순회를 하면 키 값의 오름차순의 노드를 얻을 수 있고 이진 검색과 비슷한 방식으로 검색이 가능하고 노드를 삽입하기 쉬움 

   다음 그림은 이진 검색 트리의 생성 예시 let foo = [50, 15, 62, 80, 7, 54, 11]

   검색과정 : 루트에서 시작해서 검색 값을 루트와 비교합니다. 루트보다 작으면 왼쪽에 대해 재귀하고 크다면 오른쪽으로 재귀 합니다. 일치하는 값을 찾을 때까지 절차를 반복합니다. 검색 값이 없다면 null을 반환 합니다.

   ![이미지](/2.jpg "졸업작품")
   




# [문자 크기](#h1에-해당) / [리스트](#리스트)

```md
# h1에 해당
## h2
### h3
#### h4
##### h5
###### h6
```


*이탤릭 체*  
**볼드 체**  
***하이픈***  
---
* 언오더드 리스트
- 언  
    *탭  
    *탭  
        *탭  
        *탭

1. 오더드 리스트
2. 

# 코드 블럭

```c
#include <stdio.h>

int main()
{
    printf("Hello, world")

}
```
인라인 코드 블럭 예 : `<br>` 다른예 : `Ctrl`+`A`

#외부링크
[구글로 가기](https://google.com "구글 링크")
# [내부](#)

![이미지](/1.jpg "이미지 삽입")






abcdefgujyfurfty